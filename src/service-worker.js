// src/service-worker.js - Enhanced for API caching and geolocation
// This enhanced service worker adds better caching strategies for API responses
// and improved handling of location-based resources

/* eslint-disable no-restricted-globals */

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith('/_')) {
      return false;
    }

    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// Cache Google Maps API responses (new)
registerRoute(
  ({ url }) => url.href.includes('maps.googleapis.com'),
  new CacheFirst({
    cacheName: 'google-maps-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 1 week
      }),
    ],
  })
);

// Cache Rentcast API responses (new)
registerRoute(
  ({ url }) => url.href.includes('api.rentcast.io'),
  new NetworkFirst({
    cacheName: 'rentcast-api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 1 day
      }),
    ],
  })
);

// Cache Zuper API responses with network-first strategy (new)
registerRoute(
  ({ url }) => url.href.includes('zuperpro.com/api'),
  new NetworkFirst({
    cacheName: 'zuper-api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 2 * 60 * 60, // 2 hours
      }),
    ],
  })
);

// Cache the HVAC diagnostic data with network-first strategy
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/getDiagnostics') || url.pathname.includes('/api/diagnose'),
  new NetworkFirst({
    cacheName: 'diagnostic-data',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 24 * 60 * 60, // 1 day
      }),
    ],
  })
);

// Cache the OpenAI API responses with stale-while-revalidate strategy
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/diagnose'),
  new StaleWhileRevalidate({
    cacheName: 'api-responses',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 1 week
      }),
    ],
  })
);

// Cache reference materials and static data with cache-first strategy
registerRoute(
  ({ url }) => url.pathname.startsWith('/data/'),
  new CacheFirst({
    cacheName: 'static-data',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Listen for push events (for future notifications)
self.addEventListener('push', (event) => {
  const title = 'HVAC Diagnostics Assistant';
  let body = 'New information available';
  
  // Try to parse the payload if available
  try {
    if (event.data) {
      const data = event.data.json();
      body = data.message || body;
    }
  } catch (error) {
    console.error('Error parsing push notification payload:', error);
  }
  
  const options = {
    body: body,
    icon: 'logo192.png',
    badge: 'logo192.png',
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: '1'
    },
    actions: [
      {
        action: 'view',
        title: 'View'
      }
    ]
  };

  event.waitUntil(self.registration.showNotification(title, options));
});

// Enhanced background sync for diagnostics and API requests
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-diagnostics') {
    event.waitUntil(syncDiagnostics());
  } else if (event.tag === 'sync-customer-data') {
    // New sync handler for customer data
    event.waitUntil(syncCustomerData());
  } else if (event.tag === 'sync-asset-data') {
    // New sync handler for asset data
    event.waitUntil(syncAssetData());
  }
});

// Offline fallback response for API requests (enhanced with structured fallbacks)
self.addEventListener('fetch', (event) => {
  // Only handle API requests when offline
  if (event.request.url.includes('/api/') && !navigator.onLine) {
    const handleOfflineResponse = async () => {
      try {
        // Try to match the request in the cache
        const cachedResponse = await caches.match(event.request);
        if (cachedResponse) {
          return cachedResponse;
        }
        
        // If not found in cache, return appropriate fallback based on endpoint
        if (event.request.url.includes('/api/diagnose')) {
          return createJsonResponse({
            offlineMode: true,
            message: "You're currently offline. Using limited diagnostic capabilities.",
            source: "offline"
          });
        } else if (event.request.url.includes('/api/analyze-image')) {
          return createJsonResponse({
            error: true,
            message: "Image analysis requires an internet connection.",
            systemInfo: {
              brand: "",
              model: "",
              systemType: "",
              age: ""
            }
          });
        } else if (event.request.url.includes('api.rentcast.io')) {
          return createJsonResponse({
            error: true,
            message: "Property data lookup requires an internet connection.",
            data: []
          });
        } else if (event.request.url.includes('zuperpro.com/api')) {
          return createJsonResponse({
            error: true,
            message: "Zuper API access requires an internet connection.",
            data: null
          });
        }
        
        // Default offline response for API requests
        return createJsonResponse({
          error: true,
          message: "You're offline. Please connect to the internet to use this feature."
        });
      } catch (error) {
        console.error('Error handling offline response:', error);
        return createJsonResponse({
          error: true,
          message: "An error occurred while handling the offline response."
        });
      }
    };
    
    event.respondWith(handleOfflineResponse());
  }
});

// Helper function to create JSON responses
function createJsonResponse(data) {
  return new Response(
    JSON.stringify(data),
    { 
      headers: { 'Content-Type': 'application/json' },
      status: data.error ? 503 : 200
    }
  );
}

// Placeholder function for syncing diagnostics when online
async function syncDiagnostics() {
  try {
    // Get saved diagnostics from IndexedDB or localStorage
    const offlineDiagnostics = await getOfflineDiagnosticsFromStorage();
    
    // Send each diagnostic to server when back online
    if (offlineDiagnostics && offlineDiagnostics.length > 0) {
      // Implementation would depend on your storage method
      console.log('Syncing diagnostics data...');
      // Process offline diagnostic entries here
    }
  } catch (error) {
    console.error('Error syncing diagnostics:', error);
  }
}

// New function to sync customer data to Zuper when online
async function syncCustomerData() {
  try {
    // Get saved customer data from IndexedDB or localStorage
    const offlineCustomerData = await getFromStorage('pendingSyncCustomers');
    
    if (offlineCustomerData && offlineCustomerData.length > 0) {
      console.log('Syncing customer data to Zuper...');
      // Process offline customer data here
    }
  } catch (error) {
    console.error('Error syncing customer data:', error);
  }
}

// New function to sync asset data to Zuper when online
async function syncAssetData() {
  try {
    // Get saved asset data from IndexedDB or localStorage
    const offlineAssetData = await getFromStorage('pendingSyncAssets');
    
    if (offlineAssetData && offlineAssetData.length > 0) {
      console.log('Syncing asset data to Zuper...');
      // Process offline asset data here
    }
  } catch (error) {
    console.error('Error syncing asset data:', error);
  }
}

// Generic function to get data from storage (IndexedDB or localStorage)
async function getFromStorage(key) {
  try {
    const storedData = localStorage.getItem(key);
    return storedData ? JSON.parse(storedData) : [];
  } catch (error) {
    console.error(`Error getting data from storage (${key}):`, error);
    return [];
  }
}

// Placeholder function to get offline diagnostics
async function getOfflineDiagnosticsFromStorage() {
  return getFromStorage('pendingSyncDiagnostics');
}
